<!DOCTYPE html>
<html lang="mn">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Монгол бичиг</title>
<style>
:root{
  --gap:14px;
  --bg:#f5f5f7;
  --card:#ffffff;
  --ink:#111;
  --accent:#111827;
  --radius:14px;
}

html, body {
  height: 100%;
  margin: 0;
  overflow: hidden;
}

body{
  font-family:Inter,Roboto,Arial,system-ui;
  background:var(--bg);
  color:var(--ink);
  display: flex;
  align-items: center;
  justify-content: center;
}

.grids-wrap{
  display:flex;
  flex-direction:column;
  gap:28px;
  min-width:300px;
}

.pixel-container{
  background:var(--card);
  border-radius:var(--radius);
  padding:16px;
  box-shadow:0 6px 20px rgba(0,0,0,0.07);
  display:flex;
  flex-direction:column;
  align-items:center;
  transition:transform .15s ease;
}

.pixel-container:hover{
  transform:translateY(-2px);
}

.pixel-grid{
  width:100%;
  max-width:340px;
  aspect-ratio:1/1;
  display:grid;
  grid-template-columns:repeat(13, minmax(0,1fr));
  grid-auto-rows:1fr;
  gap:1px;
  background:#ddd;
  padding:6px;
  border-radius:var(--radius);
  box-sizing:border-box;
}

.pixel{
  background:#fff;
  border-radius:4px;
  box-shadow:inset 0 0 0 1px rgba(0,0,0,0.06);
  user-select:none;
  touch-action:none;
  transition:background 0.1s ease;
}

.pixel.active{
  background:var(--accent);
}

.controls{
  display:flex;
  gap:8px;
  margin-top:12px;
  flex-wrap:wrap;
  justify-content:flex-start;
}

.btn{
  padding:8px 12px;
  background:var(--accent);
  border:none;
  border-radius:10px;
  color:#fff;
  cursor:pointer;
  font-size:13px;
}

.grid-header{
  margin:0 0 10px 0;
  font-size:1.1rem;
  font-weight:600;
}

/* --- LEFT DROPDOWN NAVIGATOR --- */
.navigator-container {
  position: fixed;
  top: 20px;
  left: 20px;
  z-index: 50;
}

#navigatorButton {
  padding: 8px 14px;
  background: var(--accent);
  color: #fff;
  border: none;
  border-radius: 10px;
  cursor: pointer;
  box-shadow: 0 3px 12px rgba(0,0,0,0.25);
  font-size: 14px;
}

.navigator-links {
  display: flex;
  flex-direction: column; /* vertical stack */
  gap: 4px;
  margin-top: 6px;
  max-height: 0;
  opacity: 0;
  overflow-y: auto;
  max-height: 80vh;
  transition: max-height 0.3s ease, opacity 0.3s ease;
}

.navigator-container:hover .navigator-links {
  max-height: 1000px; /* enough for all numbers */
  opacity: 1;
}

.navigator-links a {
  display: block;
  width: 36px;
  text-align: center;
  padding: 4px 0;
  background: #f1f1f1;
  color: #222;
  text-decoration: none;
  font-size: 12px;
  font-weight: 600;
  border-radius: 6px;
  transition: background 0.15s ease, transform 0.15s ease;
}

.navigator-links a:hover {
  background: var(--accent);
  color: #fff;
  transform: translateY(-2px);
}

@media (max-width:600px){
  .navigator-container:hover .navigator-links {
    max-height: 0;
    opacity: 0;
  }
  .pixel-grid{
    max-width:260px;
  }
}
</style>
</head>
<body>
<div class="grids-wrap" id="gridsWrap" aria-live="polite"></div>

<div class="navigator-container">
  <a href="index.html" id="back-to-typer" class="btn" style="text-decoration: none;">Back to Typer</a>
  <button id="navigatorButton">Navigator</button>
  <div id="gridNav" class="navigator-links"></div>
</div>

<script>
(function(){
const GRID_COUNT = 30;
const ROWS = 13;
const COLS = 13;

function makeRandomPattern(fillChance = 0.25){
  const pat = [];
  for(let r=0;r<ROWS;r++){
    let row = '';
    for(let c=0;c<COLS;c++) row += Math.random() < fillChance ? '#' : '.';
    pat.push(row);
  }
  return pat;
}

function savePattern(id, gridEl){
  const pixels = Array.from(gridEl.querySelectorAll('.pixel'));
  const rows = [];
  for(let r=0;r<ROWS;r++){
    let row = '';
    for(let c=0;c<COLS;c++){
      const idx = r*COLS + c;
      row += pixels[idx].classList.contains('active') ? '#' : '.';
    }
    rows.push(row);
  }
  localStorage.setItem(`grid_${id}_pattern`, JSON.stringify(rows));
}

function loadPattern(id){
  const raw = localStorage.getItem(`grid_${id}_pattern`);
  if(!raw) return null;
  try { return JSON.parse(raw); } catch { return null; }
}

const gridsWrap = document.getElementById('gridsWrap');

function createGridComponent(id, pattern){
  const container = document.createElement('div');
  container.id = `grid-${id}`;
  container.className = 'pixel-container';
  container.dataset.instanceId = id;
  container._initialPattern = pattern.slice();

  const header = document.createElement('h1');
  header.className = 'grid-header';
  header.textContent = `Зурлага ${id}`;

  const grid = document.createElement('div');
  grid.className = 'pixel-grid';

  for(let r=0;r<ROWS;r++){
    const rowStr = pattern[r] || '.'.repeat(COLS);
    for(let c=0;c<COLS;c++){
      const px = document.createElement('div');
      px.className = 'pixel';
      px.dataset.index = r*COLS + c;
      if(rowStr[c] === '#') px.classList.add('active');

      px.addEventListener('pointerdown', (e)=>{
        e.preventDefault();
        px.classList.toggle('active');
        savePattern(id, grid);
        updateBinaryValue();
        container._painting = true;
      });
      px.addEventListener('pointerup', ()=>{
        container._painting = false;
        savePattern(id, grid);
        updateBinaryValue();
      });

      grid.appendChild(px);
    }
  }

  document.addEventListener('pointerup', ()=>{ container._painting = false; });

  const controls = document.createElement('div');
  controls.className = 'controls';

  function btn(text){ const b=document.createElement('button'); b.className='btn'; b.textContent=text; return b; }

  const clearBtn = btn('Clear');
  const invertBtn = btn('Invert');
  const exportBtn = btn('Export PNG');
  const reloadBtn = btn('Reload');
  const copyBtn = btn('Copy for glyphs.js');

  function updateBinaryValue(){
    const pixels = grid.querySelectorAll('.pixel');
    let bin = '';
    pixels.forEach(p=>{ bin += p.classList.contains('active') ? '1' : '0'; });
  }

  updateBinaryValue();

  const saveGlyphsBtn = btn('Save All Glyphs');
  const loadGlyphsBtn = btn('Load My Glyphs');

  controls.append(clearBtn, invertBtn, exportBtn, reloadBtn, copyBtn, saveGlyphsBtn, loadGlyphsBtn);

  saveGlyphsBtn.addEventListener('click', saveAllGlyphs);
  loadGlyphsBtn.addEventListener('click', loadMyGlyphs);

  clearBtn.addEventListener('click', ()=>{
    grid.querySelectorAll('.pixel').forEach(p=>p.classList.remove('active'));
    savePattern(id, grid);
    updateBinaryValue();
  });

  invertBtn.addEventListener('click', ()=>{
    grid.querySelectorAll('.pixel').forEach(p=>p.classList.toggle('active'));
    savePattern(id, grid);
    updateBinaryValue();
  });

  exportBtn.addEventListener('click', ()=>{
    exportGridToPNG(grid, id);
  });

  reloadBtn.addEventListener('click', ()=>{
    const ip = container._initialPattern;
    const pixels = grid.querySelectorAll('.pixel');
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const idx = r*COLS + c;
        if(ip[r][c] === '#') pixels[idx].classList.add('active');
        else pixels[idx].classList.remove('active');
      }
    }
    savePattern(id, grid);
    updateBinaryValue();
  });

  copyBtn.addEventListener('click', () => {
    const pixels = Array.from(grid.querySelectorAll('.pixel'));
    let output = '[\n';
    for (let r = 0; r < ROWS; r++) {
        output += '    "';
        for (let c = 0; c < COLS; c++) {
            const idx = r * COLS + c;
            output += pixels[idx].classList.contains('active') ? '1' : '0';
        }
        output += '"';
        if (r < ROWS - 1) {
            output += ',\n';
        }
    }
    output += '\n]';

    const glyphId = `C${String(id).padStart(2, '0')}`;
    const finalOutput = `"${glyphId}": { "bitmap": ${output} },`;

    navigator.clipboard.writeText(finalOutput).then(() => {
        copyBtn.textContent = 'Copied!';
        setTimeout(() => {
            copyBtn.textContent = 'Copy for glyphs.js';
        }, 2000);
    }).catch(err => {
        console.error('Failed to copy text: ', err);
    });
});

  container.appendChild(header);

  const rowWrap = document.createElement('div');
  rowWrap.style.display = 'flex';
  rowWrap.style.alignItems = 'flex-start';
  rowWrap.style.gap = '24px';
  rowWrap.style.width = '100%';
  rowWrap.style.justifyContent = 'center';
  rowWrap.style.flexWrap = 'wrap';

  const explain = document.createElement('div');
  explain.style.flex = '1';
  explain.style.minWidth = '200px';
  explain.style.maxWidth = '280px';
  explain.style.background = 'var(--card)';
  explain.style.padding = '14px';
  explain.style.borderRadius = 'var(--radius)';
  explain.style.boxShadow = '0 6px 20px rgba(0,0,0,0.07)';
  explain.innerHTML = `
    <div style="font-weight:600; margin-bottom:6px; font-size:1rem;">Тайлбар</div>
    <div class="explain-text" style="font-size:0.9rem; opacity:0.85; line-height:1.4rem;">
      Зурлага ${id}-ийн утгыг энд тайлбарлана.
    </div>
  `;

  rowWrap.appendChild(grid);
  rowWrap.appendChild(explain);

  container.appendChild(rowWrap);
  container.appendChild(controls);
  return container;
}

function exportGridToPNG(gridElement, id){
  const pixels = Array.from(gridElement.querySelectorAll('.pixel'));
  const canvas = document.createElement('canvas');
  canvas.width = COLS;
  canvas.height = ROWS;
  const ctx = canvas.getContext('2d');
  pixels.forEach((p,i)=>{
    const x = i % COLS, y = Math.floor(i / COLS);
    ctx.fillStyle = p.classList.contains('active') ? '#111827' : '#ffffff';
    ctx.fillRect(x,y,1,1);
  });
  const scale = 20;
  const scaled = document.createElement('canvas');
  scaled.width = COLS * scale;
  scaled.height = ROWS * scale;
  const sctx = scaled.getContext('2d');
  sctx.imageSmoothingEnabled = false;
  sctx.drawImage(canvas,0,0,scaled.width,scaled.height);
  const a=document.createElement('a');
  a.download = `pixel-art-${id}.png`;
  a.href = scaled.toDataURL('image/png');
  a.click();
}

})();

async function saveAllGlyphs() {
    const allGlyphs = {};
    for (let i = 0; i < GRID_COUNT; i++) {
        const id = i + 1;
        let pat = loadPattern(id);
        if (pat) {
            const glyphId = `C${String(id).padStart(2, '0')}`;
            allGlyphs[glyphId] = { bitmap: pat };
        }
    }

    const res = await fetch('/save-glyphs', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ glyphs: allGlyphs })
    });
    const msg = await res.text();
    alert(msg);
}

async function loadMyGlyphs() {
    const res = await fetch('/load-glyphs');
    if (res.ok) {
        const userGlyphs = await res.json();
        for (const glyphId in userGlyphs) {
            const idMatch = glyphId.match(/^C(\d+)/);
            if (idMatch) {
                const id = parseInt(idMatch[1], 10);
                localStorage.setItem(`grid_${id}_pattern`, JSON.stringify(userGlyphs[glyphId].bitmap));
            }
        }
        alert('Glyphs loaded successfully!');
        // Re-render the current grid to show loaded changes
        const currentGridId = parseInt(document.querySelector('.pixel-container').dataset.instanceId, 10);
        renderGrid(currentGridId);
    } else {
        const msg = await res.text();
        alert(`Failed to load glyphs: ${msg}`);
    }
}
</script>
</body>
</html>
